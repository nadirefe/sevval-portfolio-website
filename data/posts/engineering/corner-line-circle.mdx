---
title: 'Computer Vision - Corner Line Circle'
publishedAt: '2020-03-22'
summary: 'This is the summary of our blog post! This is the summary of our blog post! This is the summary of our blog post!'
---

<h2 style={{ color: '#fdba74' }}> COMPUTER VISION </h2>

## **Corner, Line and Circle Detection**

In this academic lab project, it is asked to detect corners using Tomasi-Kanade cornerness measure also detecting lines and circles by using MATLAB's built-in Hough transform functions. Harris Corner Detector is a corner detection operator that is used to extract corners and infer features of an image. Harris’ corner detector takes the differential of the corner score into account with reference to direction directly, The Hough Transform is an algorithm has been modified to be able to recognize shapes such as circles and quadrilaterals of specific types. Hough Transform algorithm works within the concepts of edge image, the Hough Space and the mapping of edge points onto the Hough Space, an alternate way to represent a line, and how lines are detected.

<span style={{ fontWeight: 'bold', color: '#fdba74' }}>
  #1 Corner Detection{' '}
</span>
Tomasi-Kanade feature tracker is an approach to feature extraction. It is suggested
that conventional image registration techniques are usually expensive, primarily
for the purpose of dealing with the issue. To direct the search for the location
that yields the best match, Tomasi-Kanade uses spatial intensity information. The
analysis of far fewer possible matches between the images is quicker that conventional
techniques. In corner detection process: for each pixel, the corner operator is applied
to obtain a cornerness measure for that pixel. Then, threshold map constituted to
eliminate weak corners. At last, nonmaximal suppression is applied to eliminate points
whose cornerness measure is not larger that the cornerness values of all points within
a certain distance.

```c

function [corners] = lab4ktcorners(img)
[row,col,ch] = size(img);

if (ch == 3)
img = rgb2gray(img);
end

Corners_Filtered = zeros(size(img));
% Transforming to double
img = double(img);
Corners_Filtered = double(Corners_Filtered);

% Initializations of cornersi threshold, window size
corners = [];
T = 1000;
k = 1;

% Smoothing
Simg = lab2gaussfilt(img);

% Finding gradients
[Gx,Gy] = imgradientxy(Simg);

% Finding H for each pixel using windows
for i=k+1:k:row-k-1
for j=k+1:k:col-k-1
wx = Gx(i-k:i+k, j-k:j+k);
wy = Gy(i-k:i+k, j-k:j+k);
h1 = sum(sum(wx.^2));
h2 = sum(sum(wx.*wy));
h3 = h2;
h4 = sum(sum(wy.^2));
H = [h1,h2;h3,h4];

e = eig(H);

if (min(e)>T)

corners = [corners; i, j];

end

end

end

% Visualization
img = uint8(img);
figure;
imshow(img)
hold on;

plot(corners(:,2),corners(:,1),'r*','MarkerSize',7,'Linewidth',1);

title('Kanade-Tomasi corner detection');

end
```

<br />

<div className="flex justify-center">
  <img
    src="/images/posts/puzzle.jpeg"
    alt="cleode"
    style={{ height: '200px', display: 'inline', marginRight: '30px' }}
  />
  <img
    src="/images/posts/kanadetomasi_2.png"
    alt="facespaces"
    style={{ height: '200px', display: 'inline' }}
  />
</div>

<br />
<span style={{ fontWeight: 'bold', color: '#fdba74' }}>
  #2 Hough Transform Line Detection{' '}
</span>
The Hough Space is a 2D plane with a horizontal axis that represents the slope
and the vertical axis on the edge image representing the intercept of a line. A
line is represented in the form of y = ax + b in an edge image. As a line is
identified by its slope a and intercept b, one line on the edge image produces a
point on the Hough Space. An edge point (xi, yi) on the edge image, on the other
hand, may have an infinite number of lines passing through it.

A line in the Hough Space in the form of b = axi + yi is therefore generated by an edge point. The Hough Space in the Hough Transform algorithm is used to decide whether there is a line in the edge image.
But in this form, since slope an is undefined/infinity for vertical lines, the algorithm will not be able to detect vertical lines. Instead a straight line is represented by a line called the usual line that passes through the origin, perpendicular to the straight line to avoid this issue. The form of the normal line is ρ = x cos(θ) + y sin(θ) where ρ is the length of the normal line and θ is the angle between the normal line and the x axis.

Using this, instead of representing the Hough Space with the slope a and intercept b, it is now represented with ρ and θ where the horizontal axis are for the θ values and the vertical axis are for the ρ values. The mapping of edge points onto the Hough Space works in a similar manner except that an edge point (xᵢ, yᵢ) now generates a sinusoid in the Hough Space instead of a straight line.

```c
  function [H, T, R] = lab4houghlines(I)

  [row, col, ch] = size(I);

  img = I;

  if (ch == 3)

  img = rgb2gray(img);

  end

  img_edges = edge(img ,'Canny');

  [H,T,R] = hough(img_edges,'RhoResolution',0.5,'Theta',-90:0.5:89);

  figure('Name','Hough Transform','NumberTitle','off');

  subplot(2,2,1)

  imshow(I);

  title('Original Image');

  subplot(2,2,2)

  imshow(img_edges);

  title(sprintf('Edges using Canny Edge Detector'));

  subplot(2,2,3)

  imshow(H, [], 'XData',T,'YData',R,'InitialMagnification','fit');

  title('Hough Transform');

  xlabel('\theta'), ylabel('\rho');

  axis on, axis normal, hold on

  Thresh = ceil(0.5*max(H(:)));

  P = houghpeaks(H,20,'threshold',Thresh);

  x = T(P(:,2));

  y = R(P(:,1));

  plot(x,y,'s','color','white');

  lines = houghlines(img_edges,T,R,P,'FillGap',10,'MinLength',40);

  subplot(2,2,4)

  imshow(img),title(sprintf('Hough Lines Based on Canny Edge Detector'));

  hold on

  max_len = 40;

  min_len = 2000;

  for k = 1:length(lines)

  xy = [lines(k).point1; lines(k).point2];

  plot(xy(:,1),xy(:,2),'LineWidth',1,'Color','green');

  % Plot beginnings and ends of lines

  plot(xy(1,1),xy(1,2),'x','LineWidth',1,'Color','yellow','Markersize',3);

  plot(xy(2,1),xy(2,2),'x','LineWidth',1,'Color','red','Markersize',3);

  % Determine the endpoints of the longest line segment

  len = norm(lines(k).point1 - lines(k).point2);

  if ( len > max_len)

  max_len = len;

  xy_long = xy;

  end

  if (len < min_len)

  min_len = len;

  xy_short = xy;

  end

  end

  plot(xy_long(:,1),xy_long(:,2),'LineWidth',1,'Color','cyan');

  plot(xy_short(:,1),xy_short(:,2),'LineWidth',1,'Color','red');

  end
```

<br />

<div className="flex justify-center">
  <img
    src="/images/posts/2_graph.png"
    alt="cleode"
    style={{ height: '300px', display: 'inline', marginRight: '30px' }}
  />
  <img
    src="/images/posts/2_graph_4.png"
    alt="facespaces"
    style={{ height: '300px', display: 'inline' }}
  />
</div>

<br />
<span style={{ fontWeight: 'bold', color: '#fdba74' }}>
  #3 Hough Transform Circle Detection{' '}
</span>
The space parameter will be three dimensional, (a, b, r) and all the parameters
that satisfy (x, y) would lie on the surface of the right-angled inverted cone
whose apex is at the top of the right-angled cone (x, y, 0). The parameters of
the circle can be described in the 3D space by the intersection of several
conical surfaces defined by points on the 2D circle. The method is to set the
radius, then find the optimal circle center in a 2D parameter space, or find the
optimal radius in a one-dimensional space.

In the algorithm created:

- All circles detected with radius r such that 20 <= r <= 60 pixels by
  using Hough transform using ‘imfindcircles’ function

- ‘Sensitivity’ factor changed to test the performance of circle
  detection

- ‘ObjectPolarity’ parameter changed to detect ‘bright’ and ‘dark’
  circles separately

  ```c
  function [centersBright, radiiBright,centersDark, radiiDark] = lab4houghcircles(I)

  [row,col,ch] = size(I);

  img = I;

  if (ch==3)

  img = rgb2gray(img);

  end

  Rmin = 20;Rmax = 60;Sens = 0.9;

  [centersBright, radiiBright] = imfindcircles(I,[Rmin Rmax],'ObjectPolarity','bright','Sensitivity',Sens);

  [centersDark, radiiDark] = imfindcircles(I,[Rmin Rmax],'ObjectPolarity','dark','Sensitivity',Sens);

  imshow(I),title(sprintf('Detected Circles using Hough Transform \n %d =< Radius =< %d & Sensitivity = %.2d', Rmin, Rmax, Sens)), hold on

  viscircles(centersBright, radiiBright,'Color','b');

  viscircles(centersDark, radiiDark,'LineStyle','--');

  end
  ```

  <br />
  
<div className="flex justify-center">
  <img
    src="/images/posts/circle_graph.png"
    alt="cleode"
    style={{ height: '300px', display: 'inline', marginRight: '30px' }}
  />
  <img
    src="/images/posts/circle_graph_2.png"
    alt="facespaces"
    style={{ height: '300px', display: 'inline' }}
  />
</div>

<br/>
<br/>
